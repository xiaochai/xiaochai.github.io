---
layout: post
title: "PHPUnit"
date: 2017-09-20
categories:
  - Tech
description: 
image: /assets/images/phpunit.jpg
image-sm: /assets/images/phpunit.jpg
---

### 下载安装

phpunit的可执行文件为phar，直接下载并移动到PATH目录即可

使用phpunit.phar --version测试是否已经成功安装

对于使用composer管理项目依赖时，使用
```shell
composer require --dev phpunit/phpunit ^6.3
```
来声明对phpunit的依赖关系

另外的两个可选组件 

```shell
composer require --dev phpunit/php-invoker: 提供超时限制的函数调用方式
composer require --dev phpunit/dbunit: 对数据库交互方式的测试
```

### 约定

* 针对类```Class```的测试写在类```ClassTest```中。

* ```ClassTest```(通常)继承自```PHPUnit\Framework\TestCase```。

* 测试都是命名为```test*```的公用方法。 也可以在方法的文档注释块(docblock)中使用 ```@test``` 标注将其标记为测试方法。

* 在测试方法内，类似于```assertEquals()```这样的断言方法用来对实际值与预期值的匹配做出断言。

```php
<?php
use PHPUnit\Framework\TestCase;

class StackTest extends TestCase {
	public function testPushAndPop(){
		$stack = [];
		$this->assertEquals(0, count($stack));
		array_push($stack, 'foo');
		$this->assertEquals(1, count($stack));
		$this->assertEquals('foo', $stack[count($stack)-1]);

		$this->assertEquals('foo', array_pop($stack));
		$this->assertEquals(0, count($stack));
	}
}
```

### 使用依赖

使用```@depends```来表达依赖关系

```php
// skip others
	public function testEmpty(){
		$stack = [];
		$this->assertEmpty($stack);
		return $stack;
	}

	/**
	 * @depends testEmpty
	 */
	public function testPush(array $stack){
		array_push($stack, 'foo');
		$this->assertEquals('foo', $stack[count($stack)-1]);
		$this->assertNotEmpty($stack);
		return $stack;
	}

	/**
	 * @depends testPush
	 */
	public function testPop(array $stack){
		$this->assertEquals('foo', array_pop($stack));
	}
```

* 注意```@depends```中的生产者如果返回一个对象，则传给消费者的为对象的引用，如果需要传递副本，使用```@depends clone```

* 如果生产者测试失败了，那么依赖他的消费都将会跳过，比如testEmpty失败了，那么将产生以下输出

```
PHPUnit 6.3.0 by Sebastian Bergmann and contributors.

FSS                                                                 3 / 3 (100%)

Time: 67 ms, Memory: 8.00MB

There was 1 failure:

1) StackTest::testEmpty
Failed asserting that an array is not empty.

/home/liqingshou/work/xiaochai/phpuint/test/StackTest.php:8

FAILURES!
Tests: 3, Assertions: 1, Failures: 1, Skipped: 2.
```

* 其中第二行内容中的F表示Failed，S表示Skipped，如果是通过，则使用符号.表示，从最后一行结论可以看出，三个测试，失败了1个，跳过两个

* 可以使用多个```@depends```标注来声明多个依赖，生产者的返回值将依次传消费者的参数

* PHPUnit的执行顺序是函数出现的顺序，如果依赖在消费都之后，则会报incomplete，并会跳过对应的测试

### 数据供给器

* 使用```@dataProvider```来使用数据供给器，供给器需要返回一个多维数组或者数组的迭代器，每一次迭代生成的数组都将做为参数传给消费者

```php
<?php
use PHPUnit\Framework\TestCase;

class DataTest extends TestCase{
	/**
	 * @dataProvider additionProvider
	 */
	public function testAdd($a, $b, $expected){
		$this->assertEquals($expected, $a+$b);
	}

	public function additionProvider(){
		return [
			[0, 0, 0],
			[0, 1, 1],
			[1, 0, 1],
			[1, 1, 3],
		];
	}
}
```

* 以上返回如下信息

```
PHPUnit 6.3.0 by Sebastian Bergmann and contributors.

...F                                                                4 / 4 (100%)

Time: 54 ms, Memory: 8.00MB

There was 1 failure:

1) DataTest::testAdd with data set #3 (1, 1, 3)
Failed asserting that 2 matches expected 3.

/home/liqingshou/work/xiaochai/phpuint/test/DataTest.php:9

FAILURES!
Tests: 4, Assertions: 4, Failures: 1.
```

* 每一次返回的值可以包含一个键，用来说明本次测试用例，这样在报错的时候可以更详细

* 如果一个消费者同时有```@depends```和```@dataProvider```，那么数据供给器的数据优先传入参数

* 注意：如果一个生产者被多次依赖，那么，他只会执行一次


### 对异常进行测试

```php
<?php
use PHPUnit\Framework\TestCase;

class ExceptionTest extends TestCase{
	public function testException(){
		$this->expectException(Exception::class);
		throw new Exception("test", 1);
	}
	public function testExceptionCode(){
		$this->expectExceptionCode(1);
		throw new Exception("test", 1);
	}
	public function testExceptionMessage(){
		$this->expectExceptionMessage("test");
		throw new Exception("test", 1);
	}
	/**
	 * @expectedException Exception
	 */
	public function testExceptionLabel(){
		throw new Exception("test", 1);
	}
	/**
	 * @expectedException Exception
	 * @expectedExceptionCode 1
	 */
	public function testExceptionCodeLabel(){
		throw new Exception("test", 1);
	}
	/**
	 * @expectedException Exception
	 * @expectedExceptionMessage test
	 */
	public function testExceptionMessageLabel(){
		throw new Exception("test", 1);
	}
}
```

* 使用expectException，expectExceptionCode，expectExceptionMessage，expectExceptionMessageRegExp方法来预期接下来的调用将会抛出异常

* 也可以使用这些标注来代替```expectedException```，```expectedExceptionCode```，```expectedExceptionMessage```，```expectedExceptionMessageRegExp```，其中后面三个必须与第一个标注一起使用

* 标注时，可使用常量代表，例如```@expectedExceptionCode MyClass::ERRORCODE```

#### 对PHP错误进行测试

* 默认情况下PHPUnit会将PHP的错误、警告、提示转化为异常，分别使用```PHPUnit\Framework\Error\Error```，```PHPUnit\Framework\Error\Warning```，```PHPUnit\Framework\Error\Notice```来代表

```php
<?php
//skip others

	/**
	 * @expectedException PHPUnit\Framework\Error\Notice
	 */
	public function testPHPNotice(){
		$k == 1;
	}

	/**
	 * @expectedException PHPUnit\Framework\Error\Warning
	 */
	public function testPHPWarning(){
		$a = "abc";
		$a["abc"];
	}
```

* todo：对于```PHPUnit\Framework\Error\Error```和Fatal的测试不符合预期，后续补充

### 对输出进行测试

```php
<?php
use PHPUnit\Framework\TestCase;

class OutputTest extends TestCase{
	public function testString(){
		$this->expectOutputString("string");
		echo "string";
	}

	public function testRegExp(){
		$this->expectOutputRegex("/\d+\.\d+.\d+.\d+/");
		echo "192.168.1.1";
	}

	public function testCallback(){
		$this->setOutputCallback(function($s){
			return "a";
		});
		$this->expectOutputString("a");
		echo "test";
	}

	public function testGet(){
		echo "abc";
		$this->assertEquals("abc", $this->getActualOutput());
	}
}
```

* 以上演示了对输入进行测试处理，包括以下函数```expectOutputString```，```expectOutputRegex```，```setOutputCallback```，```getActualOutput```

### 基境(fixture)

* 在编写测试时，最费时的部分之一是编写代码来将整个场景设置成某个已知的状态，并在测试结束后将其复原到初始状态。这个已知的状态称为测试的基境(fixture)

* PHPUnit在调用测试用例的各个时机提供了不同的方法来创建基境

```php
<?php
use PHPUnit\Framework\TestCase;
class TemplateMethodsTest extends TestCase{
	// 在类初使化时调用，只会调用一次
	public static function setUpBeforeClass(){
		fwrite(STDOUT, __METHOD__ . "\n");
	}
	// 在每一次测试方法调用之前调用，每个测试用例都会调用一次
	public function setUp(){
		fwrite(STDOUT, __METHOD__ . "\n");
	}
	// 用户来验证基境是否正确，在setUp方法之后调用
	public function assertPreConditions(){
		fwrite(STDOUT, __METHOD__ . "\n");
	}
	public function testOne(){
		fwrite(STDOUT, __METHOD__ . "\n");
		$this->assertTrue(true);
	}
	public function testTwo(){
		fwrite(STDOUT, __METHOD__ . "\n");
		$this->assertTrue(false);
	}
	// 在每一次测试方法调用完成之后调用，用来测试方法运行后的状态
	public function assertPostConditions(){
		fwrite(STDOUT, __METHOD__ . "\n");
	}
	// 与setUp配对，用来销毁由setUp创建的对象或者资源
	public function tearDown(){
		fwrite(STDOUT, __METHOD__ . "\n");
	}
	// 当有不成功case的时候运行
	public function onNotSuccessfulTest(Throwable $t){
		fwrite(STDOUT, __METHOD__ . "\n");
		throw $t;
	}
	// 与setUpBeforeClass配对，在所有测试用例运行之后运行
	public static function tearDownAfterClass(){
		fwrite(STDOUT, __METHOD__ . "\n");
	}
}
```

* 运行结果

```
PHPUnit 6.3.0 by Sebastian Bergmann and contributors.

TemplateMethodsTest::setUpBeforeClass
TemplateMethodsTest::setUp
TemplateMethodsTest::assertPreConditions
TemplateMethodsTest::testOne
TemplateMethodsTest::assertPostConditions
TemplateMethodsTest::tearDown
.TemplateMethodsTest::setUp
TemplateMethodsTest::assertPreConditions
TemplateMethodsTest::testTwo
TemplateMethodsTest::tearDown
TemplateMethodsTest::onNotSuccessfulTest
F                                                                  2 / 2 (100%)TemplateMethodsTest::tearDownAfterClass


Time: 65 ms, Memory: 8.00MB

There was 1 failure:

1) TemplateMethodsTest::testTwo
Failed asserting that false is true.

/home/liqingshou/work/xiaochai/phpuint/test/TemplateMethodsTest.php:22

FAILURES!
Tests: 2, Assertions: 2, Failures: 1.
```

* 多个测试类之间需要共享基境的情况一般是由于设计的缺陷导致的（除了像数据库资源等的连接操作）

### 组织测试

* 在PHPUnit命令后跟随目录时，则会寻找*Test.php的文件

* 使用--filter来指明需要测试的方法，例如

```shell
$ phpunit.phar test/OutputTest.php --debug --filter OutputTest::testGet

PHPUnit 6.3.0 by Sebastian Bergmann and contributors.


Starting test 'OutputTest::testGet'.
.                                                                   1 / 1 (100%)abc

Time: 75 ms, Memory: 8.00MB

OK (1 test, 1 assertion)
```

#### 使用XML配置文件来编排测试顺序

* PHPUnit 会优先从当前目录查找```phpunit.xml```或者```phpunit.xml.dist```，并读取找到的配置文件

* XML配置文件的例子

```xml
<phpunit bootstrap="./autoload.php">
	<testsuites>
		<testsuite name="money">
			<directory>test</directory>
		</testsuite>
	</testsuites>
</phpunit>
```

* 可以在xml文件中指定运行测试用例的顺序

```xml
<phpunit bootstrap="./autoload.php">
	<testsuites>
		<testsuite name="money">
			<file>test/TemplateMethodsTest.php</file>
			<file>test/DataTest.php</file>
		</testsuite>
	</testsuites>
</phpunit>
```

### 有风险的测试

* 有风险的测试将会标记成R，例子如下

```php
<?php
use PHPUnit\Framework\TestCase;
class RiskTest extends TestCase{
	/**
	 * 无任何断言，包括预期的标注
	 * 此各类型默认开启，可以通过--dont-report-useless-tests选项来关闭
	 * 著使用<phpunit bootstrap="./autoload.php" beStrictAboutTestsThatDoNotTestAnything="false">来关闭
	 */
	public function testNothing(){
	}

	/**
	 * 意外的代码覆盖
	 * @todo 还没有理解意思
	 *
	 */
	public function testCoverage(){
		$this->assertTrue(true);
	}

	/**
	 * 执行过程中有输出的
	 * 此类型默认关闭，可通过--disallow-test-output打开
	 * 或者在xml中使用beStrictAboutOutputDuringTests="true"来开启
	 */
	public function testOutput(){
		echo "output";
		$this->assertTrue(true);
	}

	/**
	 * @todo 需要安装PHP_Invoker包并且pcntl扩展才可用
	 * 执行超地指定时间
	 * 通过--enforce-time-limit或者beStrictAboutTestSize="true"来开启
	 * 如果执行时间超过1秒，则视为Risk，可通过标注@large或者@media来设置这个时间为10秒、60秒
	 * 默认为@small超时为1秒
	 * 可通过配置timeoutForSmallTests值来修改@small代表的时间
	 */
	public function testTimeout(){
		sleep(2);
		$this->assertTrue(true);
	}

	/**
	 * @todo 没有实现过，需要重新实现
	 * 可以更严格对待篡改全局状态的测试
	 * 通过--strict-global-state或者beStrictAboutChangesToGlobalState="true"来启用
	*/
	public function testGlobal(){
		$GLOBAL["a"] = "2r";
		$this->assertTrue(true);
	}
}
```

### 未完成的测试与跳过的测试

```php
<?php
use PHPUnit\Framework\TestCase;

class IncompleteTest extends TestCase{
	// 使用markTestIncomplete来表示这个测试用例未完成，会生成一个I标识，参数为说明信息，可选
	public function testIncomplete(){
		$this->assertTrue(true);
		$this->markTestIncomplete("not finished");
	}

	// 使用markTestSkipped来跳过这个测试用例，会生成一个S标识，可用于当某个条件不满足时，跳过特定测试用例
	public function testSkip(){
		$this->markTestSkipped("skip this");
		$this->assertTrue(true);
	}

	/**
	 * 当requires标注不满足时，也会跳过这个测试
	 * requires的支持的参数
	 * PHP version
	 * PHPUnit version
	 * OS Linux|WIN32|WINNT
	 * function ReflectionMethod::setAccessible
	 * extension redis [version]
	 * @requires PHP 100.0.0
	 */
	public function testRequire(){
		$this->assertTrue(true);
	}
}
```

### 数据库测试

#### 准备阶段

* 理解[php Trait](http://php.net/manual/zh/language.oop5.traits.php)

* 准备DbUnit。目前可以通过composer依赖引入，或者直接下载DbUnit的方式使用DbUnit

```shell
mkdir test/tools
wget https://phar.phpunit.de/dbunit.phar -O test/tools/dbunit.phar

修改phpunit.xml，在phpunit节里加入 extensionsDirectory="test/tools"
```

* 创建测试数据库表

```sql
create database test;
create table `test` (
	`id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
	`name` varchar(20) NOT NULL DEFAULT '',
	`astro` varchar(100) NOT NULL DEFAULT '',
	PRIMARY KEY(`id`)
)ENGINE=InnoDB DEFAULT CHARSET=utf8;

```

* 准备数据文件test/users.csv

```csv
d,name,astro
1,"liqingshou","hello world"
2,"soso", "soso2501@gmail.com"
```

#### 基本测试


